% !TeX root = ../paper.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\section{Related Work}\label{sec:related_work}
  In this section, we give an outline of recent actor model implementations and elaborate on the notion of \textit{Actor Database Systems} and their requirements.

  % the actor model and the virtual actor model
  Various programming languages and libraries~\cite{armstrong:erlang,Haller:2012,akka,akka.net} implement the actor model that we introduced in the previous section.
  In 2004, \citet{bernstein:orleans} introduced the virtual actor programming model with the Orleans framework for .NET, which raises the abstraction level of actor objects.
  It still adheres to the plain actor model, but treats actors as virtual entities.
  In this model actor lifecycle management and distribution is managed by the framework or runtime and not by the application developer.
  The physical location of the actor is transparent to the application.
  The framework Orbit~\cite{orbit} provides virtual actors for the \gls{jvm}.

  % Actor Database Systems
  The actor and virtual actor programming model has increasingly been used to build soft caching layers and cloud applications for various purposes~\cite{erlang_uses,akka_uses,orleans_uses}.
  This shows the appeal of the programming model that allows developers to easily develop modular and scalable software, which can be deployed in the heterogenous parallel cloud computing infrastructure.

  Despite its popularity for application development, the actor programming model and actor programming frameworks lack state management capabilities, specifically for data-centric applications.
  The developer has to decide how to handle state persistence and how to satisfy the failure and consistency requirements of the application, because actor model implementations do no provide atomicity or consistency guarantees for state across actors.
  \Citet{manifesto} find a need for state management guarantees in actor systems and propose to integrate actor-based programming models in database management systems.
  The authors postulate that \textit{Actor Database Systems} should be designed as a logical distributed runtime with state management guarantees.
  They should allow for and encourage the design of modular, scalable and cloud-ready applications.
  \Citet{manifesto} specify needed features in their manifesto and outline four tenets that identify an \textit{Actor Database System}:

  \begin{description}
    \item[Tenet 1] Modularity and encapsulation by a logical actor construct
    \item[Tenet 2] Asynchronous, nested function shipping
    \item[Tenet 3] Transaction and declarative querying functionality
    \item[Tenet 4] Security, monitoring, administration and auditability
  \end{description}

  Most practical research in the field of actor database systems has been presented in conjunction with the Orleans framework and the Erlang programming language~\cite{Shah:reactdb,Eldeeb:transactions,Bernstein:indexing}.
  \Citet{biokoda:actordb} encapsulates a full relational SQL database inside an actor and \citet{actorbase} uses actors to build a scalable key-value store.

  % what we do
  In contrast to the other approaches, we developed our prototype using the Scala programming language and the Akka framework.
  While the Orleans framework, which has been used in earlier related work, provides virtual actors with automatic lifecycle management, Akka allows for and requires direct control over an actor's lifecycle.
  This allows close configuration of the in-memory state of the actor database system.
  Frequently accessed \glspl{dactor} can be kept in memory while ones, which haven't been involved in recent computational effort, could be temporarily persisted to disk.
  The virtual actor system implemented in the Orleans framework withdraws such control, making custom, database specific logic for configuring \gls{dactor} availability impossible.
  This makes our prototype on Akka different from the related implementations in Orleans.

  The features of our prototype relate to three of the four tenets that define an \textit{Actor Database System} according to \citeauthor{manifesto}'s manifesto~\cite{manifesto}:
  \textbf{Tenet 1} calls for the use of actors to achieve a modular logical model for data encapsulation.
  \Gls{dactor} instances are in-memory storekeepers for application data.
  They satisfy the actor definition and support high modularity.
  Furthermore, \glspl{dactor} provide a model for concurrent computation of predefined functionality that increases locality of data accesses.
  This is part of the requirements described in \textbf{Tenet 2}.
  All communication between \glspl{dactor} is asynchronous to leverage the advantages of increasingly parallel hardware.
  Our concept of \glspl{functor} allows for the definition of functionality using multiple actors' data.
  The possibility to define these \glspl{functor} as well as \gls{dactor} behavior in a declarative way relates to the second part of \textbf{Tenet 3}.
  Due to their single-threaded computation model, \glspl{dactor} can be argued to enforce internal consistency by default.
  In principle, \glspl{functor} allow for the implementation of further transaction protocols to ensure inter-\gls{dactor} consistency guarantees.
  Since the requirements listed under \textbf{Tenet 4} relate mostly to production-ready database products, we do not implement or investigate them in this research project.
  The functionality described by \citeauthor{manifesto} in tenets one through three suffices the investigation of the practical feasibility and implications of the actor database concept.

