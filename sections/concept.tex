% !TeX root = ../paper.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\section{Domain Actor Database Concept}\label{sec:concept}
  Our concept is based on the idea of actor database systems as introduced by \citet{manifesto}.
  The combination of application and data tier provides considerable advantages for data-centric systems.
  This architecture allows leveraging domain and application knowledge to dynamically model the data layout, especially concerning data partitioning and replication schemes.
  This makes the database system modular, cloud-ready, and scalable.
  % add here: why is it better to use domain knowledge to partition and distribute data?

  \subsection{Domain Actors}\label{sec:dactors}
    Similar to \citet{Shah:reactdb}, we introduce a special type of actor, called \gls{dactor}, that acts as an application-defined scaling unit.
    \Glspl{dactor} can be used to model application-domain objects and encapsulate the object's state and application logic in an actor.
    Using actors for this enforces technical encapsulation of state access due to the purely private state in actors and the need of explicit asynchronous messaging between the actors.
    The encapsulation also makes it easier to reason about state changes, bugs, and other failures, as only code within the \gls{dactor} can change the corresponding state.

    % internal data management with relations
    In-memory data contained within a \gls{dactor} instance is managed in a data structure called \gls{relation}.
    One \gls{dactor} can contain multiple \glspl{relation}.
    A \gls{relation} is, similarly to a table in the relational database model, defined as a multiset of tuples following a predefined schema.
    \Glspl{relation} provide an SQL-like interface to query and manipulate the contained data, so known and proven syntax and semantics can be used to define \gls{dactor}-behavior.
    \Glspl{relation} form a typed, \gls{dactor}-internal data model.
    Using \glspl{dactor} to implement a database leads to a modeling approach that is different to Entity-relationship modeling.
    We want to discuss the conceptual differences between the two with the following example.

    We consider the example of a web application with information on movies similar to the imdb.com or rottentomatoes.com websites.
    A standard query for those websites is to display a film with its description and cast.
    A traditional data layout might be comprised of two entities: \textit{Film} containing the film's ID, title, description and release date and \textit{Actor} containing the actor's ID and name.
    Those two entities might be in a N-to-M relation (\textit{Cast}) with an attribute showing the actor's role in the film.
    In contrast to the relational model, our model, shown in \cref{fig:film_diagram}, consists of one \gls{dactor} type and two \glspl{relation} and is denormalized.
    The information contained in the \textit{Actor} entity is distributed across the \code{Cast} \glspl{relation}.
    This allows us to answer the standard queries from one single actor instance instead of joining the result together from different \glspl{dactor} instances, which could be distributed across a network.

    This approach to layout an application's data results in much smaller data sizes per \gls{dactor} compared to typical database tables and enables many business-logic-driven approaches to scaling, data partitioning, and caching.
    The trade-off to take into account, however, is a large number of \gls{dactor} instances and a denormalized schema.

    \begin{figure}
      \centering

      \begin{subfigure}[b]{0.44\textwidth}
        \centering
        \includestandalone[width=\textwidth]{pictures/tikz/dactor_diagram}
        \caption{Graphical representation of the \texttt{Film} \gls{dactor} type definition.}
        \label{fig:film_diagram}
      \end{subfigure}\hfill
      \begin{subfigure}[b]{0.54\textwidth}
        \centering
        \scriptsize
\begin{lstlisting}[language=Scala]
class Film(id: Id) extends Dactor(id) {
  override protected val relations = {
    Film.Info -> SingleRowRelation(Film.Info),
    Film.Cast -> RowRelation(Film.Cast)
  }
  // define Dactor behavior
  override def receive: Receive = ???
}
object Film {
  object FilmInfo extends RelationDef {
    val title = ColumnDef[String]("title")
    val description = ColumnDef[String]("description")
    val release = ColumnDef[ZonedDateTime]("release")
  }
  object Cast extends RelationDef {
    val actorId = ColumnDef[Id]("actor_id")
    val name = ColumnDef[String]("actor_name")
    val rolename = ColumnDef[String]("role_name")
  }
}
\end{lstlisting}
        \subcaption{Example code using our framework.}
        \label{lst:film_definition}
      \end{subfigure}
      \caption[\texttt{Film} Dactor type definition with two relations of the example application.]{\code{Film} \gls{dactor} type definition with two relations of the example application.}
      \label{fig:film_dactor_definition}
    \end{figure}


    % logic and processing capabilities
    As \glspl{dactor} not only contain data, but also the corresponding domain logic, computation is executed concurrently.
    Actors provide single-threaded semantics, which makes enforcing constraints on data tied to one domain object stored inside a \gls{dactor} easy.
    While state querying and modification within \glspl{dactor} is possible in a declarative way, the application developer can explicitly define the communication across all kinds of actors via asynchronous messages and how the \glspl{dactor} handle the said messages.
    The explicit message definition and handling differentiates \glspl{dactor} from \citet{Shah:reactdb}'s reactors, as reactors can be used as relational entities and hide the message passing from the developer.

  \subsection{Communication between Domain Actors}\label{sec:dactor_comm}
    Not all computation can be done with the information residing in a single \gls{dactor}.
    Hence, communication between \glspl{dactor} is required.
    Explicit, asynchronous message passing allows application developers to chose the right messaging pattern for their use case.
    The choice is heavily influenced by the data layout used for the \glspl{dactor} and sets the level of parallelization and the network-load for the computation.

    We consider three main messaging patterns for inter-\gls{dactor} communication, which are shown in \cref{fig:comp_patterns}.
    Those messaging primitives are provided in our framework and can be combined to create more complex message flows and computational models.

    \begin{figure}
      \centering

      \begin{subfigure}[t]{0.32\textwidth}
        \centering
        \includestandalone[width=\textwidth]{pictures/tikz/cascading_computation}
        \subcaption{Cascading Computation}
        \label{fig:comp_pattern_1}
      \end{subfigure}\hfill
      \begin{subfigure}[t]{0.32\textwidth}
        \centering
        \includestandalone[width=\textwidth]{pictures/tikz/sequential_computation}
        \subcaption{Sequential Computation}
        \label{fig:comp_pattern_2}
      \end{subfigure}\hfill
      \begin{subfigure}[t]{0.32\textwidth}
        \centering
        \includestandalone[width=\textwidth]{pictures/tikz/concurrent_computation}
        \subcaption{Concurrent Computation}
        \label{fig:comp_pattern_3}
      \end{subfigure}
      \caption{Inter-\gls{dactor} communication patterns. Gray bars indicate that an actor holds state that is related to the showed message flow.}
      \label{fig:comp_patterns}
    \end{figure}

      The first messaging pattern is \textbf{Cascading Computation}.
      A high-level message to an initial \gls{dactor} (\gls{dactor} A), will trigger successive messages to other \glspl{dactor}, which are hidden from the original requester.
      Following \glspl{dactor} can also trigger further messages themselves.
      As one can see in \cref{fig:comp_pattern_1}, this pattern is comparable to function calls in \gls{oop}.
      But contrary to simple function calls, messages in this pattern are sent asynchronously.
      This means that the requesting \gls{dactor} has to manage the state of pending responses.
      This clutters the domain logic in the \gls{dactor} and leads to complex and error-prone code.
      If used sparsely, this pattern supports separation of concerns and the tell-don't-ask paradigm.

      \Cref{fig:comp_pattern_2} shows the \textbf{Sequential Computation} pattern.
      It is used for computations that consist of consecutive steps, where each step depends on the previous step's result, such as filter chains.
      This pattern can be implemented via \glspl{functor}, which are \gls{dactor}-proxies provided by our framework.
      We introduce the concept of \glspl{functor} in \cref{subsec:multi_dactor_queries}.
      Using a \gls{functor} to process the consecutive steps of the computational chain relieves \gls{dactor} A from dealing with intermediate state, because it is managed by the \gls{functor}.
      Each \gls{functor} only has to deal with one request-response pair at a time, which leads to a simple state and processing logic for the \gls{functor} itself.

      The \textbf{Concurrent Computation} messaging pattern also makes use of \glspl{functor} to encapsulate the processing of multiple request-response pairs.
      The concurrent \gls{functor} sends messages to several \glspl{dactor} in parallel and collects the results when they are finished to forward them to its creator.
      It allows for highly parallelized computations as all involved \glspl{dactor} are messaged at the same time and calculate their responses concurrently.