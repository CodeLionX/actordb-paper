% !TeX root = ../paper.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\section{Domain Actor Database Framework}\label{sec:framework}
  After describing the general concept of an \textit{Actor Database System}, we present the implementation of a proof-of-concept application development framework, which allows for the definition of an application's data model and the provisioning of corresponding \glspl{dactor} as part of the application runtime.

  \subsection{Domain Actor Design}\label{subsec:domain_actor_design}
    To illustrate the definition of \code{Dactor}s, we use the example introduced in \cref{sec:dactors}, which is schematically depicted in \cref{fig:film_diagram}.
    The corresponding definition of the \code{Film}'s data model is shown in \cref{lst:film_definition}.
    Developers can model the application's domain objects by defining \gls{dactor} types as subclasses of the framework-provided \code{Dactor} class in a declarative way.
    Instances of such user-defined \gls{dactor} types are managed by the framework and are available for messaging in a consistent namespace.
    Using the column's predefined data types, all functions support compile-time type-safety.
    Due to the \gls{dactor} system sharing the application's runtime and programming environment, these data or object types are equal to the types handled in any application logic.
    Thus, this approach helps eliminate the impedance mismatch between application logic and data tier with regard to handled data types and object (de-)serialization.
  
  \subsection[Multi-Dactor Queries]{Multi-\Gls{dactor} Queries}\label{subsec:multi_dactor_queries}
    The trade-off for the denormalized schema definition is that inserting new information about an actor (person) starring in a film becomes an operation that involves a multitude of \gls{dactor} instances.
    Implementation examples for this functionality and the trade-off are discussed in the following.
    
    Explicit messaging and complementary actor behavior are used to implement the cascading communication pattern described in Section~\ref{sec:concept}.
    Besides this, \glspl{functor} are the framework's system, which enable inter-\gls{dactor} communication and computations.
    \Glspl{functor} encapsulate the processing of a high-level request in a new, short-living actor.
    They are able to communicate with other \glspl{dactor}, track the state of pending requests and handle failure cases.
    Every actor can create a new \gls{functor} to encapsulate multiple depending requests to \glspl{dactor}.
    The \gls{functor} handles the message processing and sends the final result or a failure message back to its parent actor before stopping itself.
    While the basic functionality of the two \gls{functor} types for sequential and concurrent computation is discussed in \cref{sec:concept}, this section focuses on the definition of a concrete function integrating data from multiple \glspl{dactor}.
    
    \Glspl{functor} are actors with a limited lifetime.
    They are instantiated once a defined \gls{functor} is called by a \gls{dactor} or other actor and deleted once they return the final response or encounter a failure.
    \Glspl{functor} are always called from an Akka actor as a child actor.
    This Akka-specific hierarchical relationship enables notifying the calling actor even in case of an unforseen crash of the \gls{functor} themselves which in turn allows to trigger error handling, e.g. retrying the \gls{functor} execution.
    
    Returning to the web application example, we can define simple functionality concerning instances of both \gls{dactor} types defined in Section~\ref{subsec:domain_actor_design}.
    Adding a new character role to a film, played by a specific actor, involves changes to \code{Film} and \code{Actor} instances.
    We describe the implementation of this functionality using the concurrent and sequential computation patterns, introduced in \cref{sec:dactor_comm}.
    
    \Cref{fig:functor_diagram} displays the message-flow between the involved \glspl{dactor} and \glspl{functor}, as well as their supervision relations.
    To provide a top-level function that takes only an \code{Actor} id, a \code{Film} id, as well as a rolename and adds the corresponding Actor information to the Film's cast list and vice versa, this example utilizes a concurrent \gls{functor} wrapping two sequential \glspl{functor}.
    Both sequential \glspl{functor} are comprised of two subsequent steps:
    The first sequential \gls{functor} queries information from the Film \gls{dactor} instance, which is needed to add the film to the Actor \gls{dactor}'s filmography \gls{relation}, i.e. the film's title.
    Then it sends a message to the Actor \gls{dactor} containing said data to trigger the insertion of the film.
    The second sequential \gls{functor} queries the Actor instance's data, which is necessary to add them to the Film's cast \gls{relation}, i.e. their name.
    Using this data and their rolename the \gls{functor} then sends another message to the Film \gls{dactor} to trigger an insertion into its cast \gls{relation}.
    Both sequential \glspl{functor} are executed in parallel using a concurrent \gls{functor}, which only sends a successful response to its caller after both sequential \glspl{functor} have sent their responses to the concurrent \gls{functor}.
    
    \begin{figure}
      \centering
      \includestandalone[width=\textwidth]{pictures/tikz/functor_diagram}
      \caption{Component diagram indicating the message flow through \gls{functor} objects and their supervision by the calling actor or \gls{dactor}. Arrow and dashed arrow pairs indicate corresponding request and response messages. The outgoing requests of each sequential \gls{functor} are numbered to indicate their order.}
      \label{fig:functor_diagram}
    \end{figure}
    
    Using the parent-child relationship between calling actors and \glspl{functor} enables a framework-level supervision of \glspl{functor}, which are currently computing or waiting on results from down-stream \glspl{dactor}.
    The supervision concept between parent and child actors in the Akka framework, termed parental supervision, enables passing back the control flow to the parent actor in case that a child actor, in this case a \gls{functor}, fails.
    The calling actor can then react to the failure by resuming or restarting the \gls{functor}, stopping this computation, or escalating the failure to its own parent.
    The correct course of action depends on the desired application behavior.
  
  \subsection{Framework Discussion}\label{subsec:framework_discussion}
    We presented an actor database framework and showcased some of its functionality in detail.
    In particular, the described feature set is aimed to alleviate some of the problems, which arise from a distributed database system.
    In this section we discuss three core problems, which are specific or pose additional challenges in a distributed setting:
    
    \textbf{Data partitioning} in an actor database system differs fundamentally from common partitioning techniques used in relational databases.
    While large tables are typically partitioned based on a specific column's value or the hash thereof, our framework provides \glspl{dactor} as entities for data encapsulation and partitioning.
    \Glspl{dactor} can be provisioned across multiple virtual runtimes and physical machines, because every \gls{dactor} instance is independent of the others and the only mean of communication is message passing.
    As such, they provide flexible, fine-grained data partitioning based on application needs.
    
    From the distributed setting of the database system the new problem of partition or \textbf{actor discovery} arises.
    The framework maintains a unified namespace, in which each \gls{dactor} instance is identified by its \gls{dactor} type and a unique id.
    In fact, querying a specific \gls{dactor} just requires obtaining the messaging address from the nameservice and sending a message to it.
    In the case of a multi-node deployment, this is complemented by the functionality of Akka Cluster Sharding~\cite{akka:clustersharding}, which routes the messages to the right physical host.
    
    Finally, \textbf{failure handling}, especially with regard to computations relying on multiple \glspl{dactor}' data, requires careful monitoring due to \gls{dactor} distribution.
    Building on the Akka framework's parent-child supervision concept, our framework allows for transparent failure handling configurations.
    Failures can be handled within \glspl{dactor} if appropriate.
    In case of multi-\gls{dactor} queries a fail-fast approach is chosen to allow calling actors or \glspl{dactor} to react to exceptions in a timely manner.
